---

* 엔티티에는 가급적 Setter 를 사용하지 말자.
    * Setter 가 모두 열려있다면, 변경 포인트가 너무 많아서 유지보수가 어렵다.


* 모든 연관관계는 지연로딩으로 설정!
    * 즉시로딩(EAGER)는 예측이 어렵고, 어떤 SQL 이 실행될지 추적하기가 어렵다. 특히 JPQL 을 실행 할때 N + 1 문제가 발생한다.
    * 실무에서 모든 연관관계는 지연로딩(LAZY)으로 설정해야 한다.
        * 연관된 Entity 를 함께 DB 에서 조회해야 하면, fetch join 또는 Entity Graph 기능을 사용한다.
        * @XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야 한다.
            * XToMany -> default : LAZY
            * @ManyToOne(fetch = FetchType.LAZY) -> static import -> fetch = LAZY


* 컬렉션은 필드에서 초기화 하자.
    * 컬렉션은 필드에서 바로 초기화 하는 것이 안전하다
        * NULL 문제에서 안전하다.
        * 하이버네이트는 인테테를 영속화 할 때, 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다.
        * 만약 getOrders() 처럼 임의의 메서드에서 컬렉션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발행할 수 있다.
        * 따라서 필드레벨에서 생성하는 것이 가장 안전하며, 코드도 간결하다.


* 테이블, 컬럼
    * 설정 관련 - SpringPhysicalNamingStrategy
    * 스프링 부트 신규 설정
        * 1 - 카멜케이스 -> 언더스코어(orderItem -> order_item)
        * 2 -.(점) -> _(언더스코어)
        * 3 - 대문자 -> 소문자

* 쿼리 &Jpql
    * 쿼리는 데이터베이스를 대상으로 쿼리조회, jpql 은 Entity 객체 를 대상으로 조회한다.

* 준영속 엔티티
    * 영속성 컨텍스트가 더는 관리하지 않는 엔티티를 말한다.
    * 준영속 엔티티를 수정하는 2가지 방법
        * 변경 감지 기능 사용 - 병합보단 변경감지를 이용하자.
        * 병합(merge) 사용
    * 컨트롤러에서 어설프게 엔티티를 생성하지 마세요.
    * 트랜잭션이 있는 서비스 계층에 식별자('id") 와 변경할 데이터를 명확하게 전달하자(paprameter or dto)
    * 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔테테를 조회하고, 엔티티의 데이터를 직접 변경하세요.
    * 트랜잭션 커밋 시점에 변경 감지가 실행된다.


* OSIV
    * Open Session In View : 하이버네이트
    * Open EntityManager In View : JPA
    * (관례상 OSIV 라 한다)

* OSIV ON
  `spring.jpa.open-in-view` : true 기본 값  
  이 기본값을 뿌리면서 애플리케이션 시작 시점에 warn 로그를 남기는 것은 이유가 있다.  
  OSIV 전략은 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시점부터 API 응답이 끝날 때 까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지한다  
  그래서 지금까지 View Template 나 API 컨트롤러에서 지연 로딩이 가능 했던 것이다.  
  지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 데이터베이스 커넥션을 유지 한다.  
  이것 자체가 큰 장점이다.

그런데 이 전략은 너무 오랜시간동안 데이터베이스 커넥션 리소스를 사용하기 때문에, 실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자랄 수 있다.  
이것은 결국 장애로 이어진다.  
예를 들어 컨트롤러에서 외부 API 를 호출하면 외부 API 대기 시간 만큼 커넥션 리소스를 반환하지 못하고, 유지해야 한다.

* OSIV OFF
  `spring.jpa.open-in-view: false` : true 종료  
  OSIV 를 끄면 트랜잭션을 종료할 때 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환한다.  
  따라서 커낵션 리소스를 낭비하지 않는다.  
  OSIV 를 끄면 모든 지연로딩을 트랜잭션 안에서 처리해야 한다. 따라서 지금까지 작성한 많은 지연 로딩 코드를 트랜잭션 안으로 넣어야 하는 단점이 있다. 그리고 view template 에서 지연로딩이 동하하지
  않는다.결론적으로 트랜잭션이 끝나기 전에 지연 로딩을 강제로 호출해 두어야 한다.  


 


